import crypto from 'crypto';
import fastGlob from 'fast-glob';
import fs from 'fs-extra';
import { replace } from 'lodash';
import path from 'path';
import { EnvFile, EnvrcConfig, FileOperationResult } from '../types';

export class FileUtils {
  /**
   * Find all .env files for a specific environment
   */
  static async findEnvFiles(
    environment: string,
    cwd: string
  ): Promise<EnvFile[]> {
    const pattern = `**/.env.${environment}`;
    const encryptedPattern = `**/.env.${environment}.gpg`;

    const [envFiles, encryptedFiles] = await Promise.all([
      fastGlob(pattern, { cwd, dot: true }),
      fastGlob(encryptedPattern, { cwd, dot: true }),
    ]);

    const results: EnvFile[] = [];

    // Add regular env files
    for (const filePath of envFiles) {
      results.push({
        path: path.join(cwd, filePath),
        stage: environment,
        encrypted: false,
        exists: true,
      });
    }

    // Add encrypted env files
    for (const filePath of encryptedFiles) {
      const decryptedPath = replace(filePath, '.gpg', '');
      results.push({
        path: path.join(cwd, decryptedPath),
        stage: environment,
        encrypted: true,
        exists: true,
      });
    }

    return results;
  }

  /**
   * Find all environments in the project
   */
  static async findAllEnvironments(cwd: string): Promise<string[]> {
    const pattern = '**/.env.*';
    const files = await fastGlob(pattern, { cwd, dot: true });

    const environments = new Set<string>();

    for (const file of files) {
      const basename = path.basename(file);
      const match = basename.match(/^\.env\.([^.]+)(\.gpg)?$/);
      if (match && match[1]) {
        environments.add(match[1]);
      }
    }

    return Array.from(environments).sort();
  }

  /**
   * Check if file exists
   */
  static async fileExists(filePath: string): Promise<boolean> {
    try {
      const stat = await fs.stat(filePath);
      return stat.isFile();
    } catch {
      return false;
    }
  }

  /**
   * Create backup of a file
   */
  static async createBackup(filePath: string): Promise<string> {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8);
    const backupPath = `${filePath}.backup.${timestamp}.${random}`;
    await fs.copy(filePath, backupPath);
    return backupPath;
  }

  /**
   * Remove backup file
   */
  static async removeBackup(backupPath: string): Promise<void> {
    if (await this.fileExists(backupPath)) {
      await fs.remove(backupPath);
    }
  }

  /**
   * Get file hash for comparison
   */
  static async getFileHash(filePath: string): Promise<string> {
    const fileBuffer = await fs.readFile(filePath);
    return crypto.createHash('md5').update(fileBuffer).digest('hex');
  }

  /**
   * Compare two files by hash
   */
  static async filesAreIdentical(
    file1: string,
    file2: string
  ): Promise<boolean> {
    if (!(await this.fileExists(file1)) || !(await this.fileExists(file2))) {
      return false;
    }

    const [hash1, hash2] = await Promise.all([
      this.getFileHash(file1),
      this.getFileHash(file2),
    ]);

    return hash1 === hash2;
  }

  /**
   * Read .envrc file and parse it
   */
  static async readEnvrc(cwd: string): Promise<EnvrcConfig> {
    const envrcPath = path.join(cwd, '.envrc');

    if (!(await this.fileExists(envrcPath))) {
      return {};
    }

    try {
      const content = await fs.readFile(envrcPath, 'utf-8');
      const config: EnvrcConfig = {};

      // Parse simple export statements
      const lines = content.split('\n');
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith('export ')) {
          const exportStatement = trimmed.substring(7);
          const [key, ...valueParts] = exportStatement.split('=');
          if (key && valueParts.length > 0) {
            let value = valueParts.join('=');
            // Remove quotes if present
            value = value.replace(/^["']|["']$/g, '');
            config[key.trim()] = value;
          }
        }
      }

      return config;
    } catch (error) {
      console.warn(`Warning: Could not read .envrc file: ${error}`);
      return {};
    }
  }

  /**
   * Write .envrc file
   */
  static async writeEnvrc(
    cwd: string,
    config: EnvrcConfig
  ): Promise<FileOperationResult> {
    const envrcPath = path.join(cwd, '.envrc');

    try {
      const lines = ['# Environment secrets generated by envx', ''];

      for (const [key, value] of Object.entries(config)) {
        lines.push(`export ${key}="${value}"`);
      }

      lines.push(''); // End with newline

      await fs.writeFile(envrcPath, lines.join('\n'), 'utf-8');

      return {
        success: true,
        message: 'Successfully wrote .envrc file',
        filePath: envrcPath,
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to write .envrc file: ${error}`,
        filePath: envrcPath,
        error: error as Error,
      };
    }
  }

  /**
   * Create a template .env file
   */
  static async createEnvTemplate(
    filePath: string,
    template?: string
  ): Promise<FileOperationResult> {
    try {
      let content = '';

      if (template && (await this.fileExists(template))) {
        // Use provided template file
        content = await fs.readFile(template, 'utf-8');
      } else {
        // Create basic template
        content = [
          '# Environment variables',
          '# Add your environment-specific variables here',
          '',
          '# Example:',
          '# DATABASE_URL=',
          '# API_KEY=',
          '# DEBUG=false',
          '',
        ].join('\n');
      }

      await fs.writeFile(filePath, content, 'utf-8');

      return {
        success: true,
        message: `Successfully created .env file`,
        filePath,
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to create .env file: ${error}`,
        filePath,
        error: error as Error,
      };
    }
  }

  /**
   * Generate a random secret
   */
  static generateRandomSecret(length: number = 32): string {
    return crypto.randomBytes(length).toString('hex');
  }

  /**
   * Generate stage secret variable name
   */
  static generateSecretVariableName(stage: string): string {
    return `${stage.toUpperCase()}_SECRET`;
  }

  /**
   * Ensure directory exists
   */
  static async ensureDir(dirPath: string): Promise<void> {
    await fs.ensureDir(dirPath);
  }

  /**
   * Get relative path from cwd
   */
  static getRelativePath(absolutePath: string, cwd: string): string {
    return path.relative(cwd, absolutePath);
  }

  /**
   * Validate environment name
   */
  static isValidEnvironmentName(name: string): boolean {
    // Allow alphanumeric, hyphens, underscores
    return /^[a-zA-Z0-9_-]+$/.test(name);
  }

  /**
   * Get encrypted file path
   */
  static getEncryptedPath(filePath: string): string {
    return `${filePath}.gpg`;
  }

  /**
   * Get decrypted file path
   */
  static getDecryptedPath(encryptedPath: string): string {
    return replace(encryptedPath, '.gpg', '');
  }

  /**
   * Check if path is encrypted file
   */
  static isEncryptedFile(filePath: string): boolean {
    return filePath.endsWith('.gpg');
  }

  /**
   * Get file stats
   */
  static async getFileStats(
    filePath: string
  ): Promise<{ size: number; mtime: Date }> {
    const stats = await fs.stat(filePath);
    return {
      size: stats.size,
      mtime: stats.mtime,
    };
  }
}
